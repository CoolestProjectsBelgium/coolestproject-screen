{{#each buffers}}
    <div id="{{this}}" height="100%" width="100%" class="slide"></div>
{{/each}}
<div id="text">
</div>
<script>
    const buffers = {{{bufferArray}}};

    function sleep(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
    }

    //buffer iterator
    function cycleBuffers() {
        
        let index = 0;
        return {
             next: function() {
                 if(buffers.length == index){
                     index = 0;
                 }
                 return {
                     value: buffers[index++],
                     done: false
                 }
             }
        }
    }
    
    new Promise(async () => {
        const bufferIterator = new cycleBuffers();

        // load backup slide
        let slide_content = null;
        slide_content = await fetch('{{backup_slide}}', {cache: "force-cache"});
        if(!slide_content.ok){
            throw new Exception("Backup slide not found !!");
        }
        const default_text = await slide_content.text();

        let b1 = bufferIterator.next().value;
        let b2 = bufferIterator.next().value;
        for(;;){
            const response = await fetch('{{slides_url}}');
            const slides = await response.json();
            let sleepTime = 0;
            let content_text = null;
            for(let slide of slides){
                slide_content = await fetch(slide.url);
                content_text = await slide_content.text(); 
                if(!slide_content.ok){
                    // backup should always work (local file)
                    content_text = default_text;
                    sleepTime = {{backup_wait}};
                }
                sleepTime = slide.sleep;

                //get message if any, if the call fails just keep displaying the last one
                message_content = await fetch('{{message_url}}');
                message_text = await message_content.text();
                const textNode = document.getElementById('text');
                if(message_content.ok){
                    textNode.innerHTML = message_text;
                }

                // get next buffers
                b2 = b1;
                b1 = bufferIterator.next().value;
                
                const b1Node = document.getElementById(b1);
                const b2Node = document.getElementById(b2);
                b1Node.innerHTML = content_text;
    
                //switch visibility of buffer
                b1Node.classList.remove("fadeOut");
                b1Node.classList.add("fadeIn");
                
                b2Node.classList.remove("fadeIn");
                b2Node.classList.add("fadeOut");
                
                await sleep(sleepTime);
            }
        }
    });
    
</script>